✦ Jasne, oto propozycja planu analizy danych dla Twojej pracy magisterskiej, oparta na plikach z katalogu
  gke_stress01. Plan jest przygotowany w formie listy zadań, która krok po kroku prowadzi przez proces analizy.

  Plan Analizy Danych (dla gke_stress01)

   1. Charakterystyka obciążenia wejściowego (Stress Testu)
       * Cel: Zrozumienie, jakiemu obciążeniu poddany był klaster.
       * Źródło danych: gke_stress01/gke_stress01_k6_results.txt.
       * Zadania:
           * Wyodrębnienie kluczowych metryk z testu k6:
               * Liczba wirtualnych użytkowników (VUs).
               * Czas trwania testu.
               * Liczba żądań na sekundę (requests_per_second).
               * Wartości opóźnień (latency): średnia, p95, p99.
               * Współczynnik błędów (http_req_failed).

   2. Analiza wykorzystania zasobów na poziomie węzłów (Nodes)
       * Cel: Ocena, jak infrastruktura (maszyny wirtualne) zareagowała na obciążenie.
       * Źródła danych: gke_stress01/gke_stress01_node_10-10-0-4/ i gke_stress01/gke_stress01_node_10-10-0-5/.
       * Zadania:
           * Analiza utylizacji CPU w czasie dla każdego węzła.
           * Analiza utylizacji Pamięci RAM w czasie dla każdego węzła.
           * Analiza wykorzystania sieci (bajty odebrane/wysłane) dla każdego węzła.
           * Analiza operacji I/O dysku w czasie dla każdego węzła.

   3. Analiza wykorzystania zasobów na poziomie aplikacji (Namespace)
       * Cel: Zrozumienie, jak sama aplikacja (jej pody) konsumowała zasoby w odpowiedzi na stress test.
       * Źródło danych: gke_stress01/gke_stress01_namespace/.
       * Zadania:
           * Analiza zużycia CPU przez pody aplikacji w czasie.
           * Analiza zużycia pamięci RAM przez pody aplikacji w czasie.
           * Analiza ruchu sieciowego generowanego przez aplikację (pasmo przychodzące i wychodzące).

   4. Analiza mechanizmów skalowania Kubernetes
       * Cel: Sprawdzenie, czy i jak klaster skalował aplikację w odpowiedzi na rosnące obciążenie.
       * Źródło danych: gke_stress01/gke_strews01_kubelet_running_pods.csv.
       * Zadania:
           * Analiza liczby działających podów w czasie.
           * Określenie momentów, w których następowało skalowanie w górę (dodawanie podów) i w dół (usuwanie podów).

   5. Korelacja i synteza wyników
       * Cel: Połączenie danych z różnych źródeł w celu wyciągnięcia wniosków. To najważniejsza część analizy.
       * Zadania:
           * Nałożenie na siebie danych o obciążeniu (np. żądania/s z k6) i utylizacji zasobów (np. CPU węzłów), aby
             zobaczyć bezpośrednią zależność.
           * Porównanie momentu wzrostu liczby podów z metrykami wydajności aplikacji (np. opóźnieniami p95). Czy
             skalowanie pomogło utrzymać niskie opóźnienia?
           * Zestawienie zużycia zasobów na poziomie węzłów i na poziomie aplikacji, aby ocenić "narzut" systemowy.

  ---

  Propozycje Wykresów:

  Aby analiza wyglądała profesjonalnie, kluczowa jest wizualizacja danych. Oto propozycje wykresów dla każdego z
  punktów planu:

   1. Wykresy obciążenia (Stress Test):
       * Wykres liniowy: "Liczba żądań na sekundę (RPS) w czasie". Oś X: czas, Oś Y: RPS.
       * Wykres liniowy: "Opóźnienia (p95 i średnia) w czasie". Oś X: czas, Oś Y: czas odpowiedzi w ms. Dwie linie na
          jednym wykresie do porównania.

   2. Wykresy zasobów węzłów (Nodes):
       * Wykres liniowy: "Utylizacja CPU na obu węzłach". Oś X: czas, Oś Y: Utylizacja CPU w %. Dwie linie (jedna dla
          każdego węzła) pozwolą na łatwe porównanie obciążenia między nimi.
       * Wykres liniowy: "Utylizacja Pamięci RAM na obu węzłach". Analogicznie do CPU.

   3. Wykresy zasobów aplikacji (Namespace):
       * Wykres liniowy: "Sumaryczne zużycie CPU i Pamięci przez aplikację". Oś X: czas, Oś Y1: CPU (np. w
         rdzeniach), Oś Y2: Pamięć (np. w GB). Można użyć wykresu z dwiema osiami Y.

   4. Wykresy skalowania:
       * Wykres schodkowy (step chart): "Liczba aktywnych podów w czasie". Oś X: czas, Oś Y: liczba podów. Wykres
         schodkowy idealnie pokazuje dyskretne zmiany w liczbie replik.

   5. Wykresy korelacyjne (najważniejsze):
       * Wykres z dwiema osiami Y:
           * Lewa oś Y: "Liczba żądań na sekundę (RPS)".
           * Prawa oś Y: "Średnia utylizacja CPU węzłów (%)".
           * Oś X: "Czas".
           * Wniosek, jaki można wyciągnąć: Jak wzrost obciążenia wpływa bezpośrednio na zasoby sprzętowe.
       * Wykres z dwiema osiami Y:
           * Lewa oś Y: "Liczba aktywnych podów".
           * Prawa oś Y: "Opóźnienie p95 (ms)".
           * Oś X: "Czas".
           * Wniosek, jaki można wyciągnąć: Czy dodanie nowych podów (skalowanie) skutecznie przeciwdziałało
             wzrostowi opóźnień.

  Taki plan i zestaw wykresów stanowią solidną podstawę do przeprowadzenia szczegółowej i wartościowej analizy w
  ramach pracy magisterskiej. Powodzenia